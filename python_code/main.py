import copy
import pickle
import random as rnd

from python_code.methods.matrix import *
import python_code.methods.equation as equation
from python_code.staf.sympy_init import *
from python_code.staf.renaming import *

def определитель(*args, **kwargs) -> (целое_число, дробное_число):
    """Автоматическое нахождение определителя"""
    return determinant.auto_det(*args, **kwargs)


class Матрица:
    """Класс, содержащий методы работы с матрицами и векторами (матрицами с одним столбцом или строкой)"""

    контейнер_для_матрицы = []

    def __init__(конкретная_матрица, *данные, **kwargs):
        # Эти присвоения нужны для возможности быстро использовать эти методы, имея только экземпляр матрицы
        конкретная_матрица.итерационные_методы = iterations
        конкретная_матрица.гаусс = gauss
        конкретная_матрица.определители = determinant
        if длина(данные) == 1:
            if класс_является_подклассом(данные[0], целое_число):
                конкретная_матрица.матрица = [[0 for j in диапазон(данные[0])] for i in диапазон(данные[0])]
            elif класс_является_подклассом(данные[0], список):
                if класс_является_подклассом(данные[0][0], список):
                    новая_матрица = данные[0]
                    длина_строки = длина(новая_матрица[0])
                    for строка in новая_матрица:
                        if длина_строки != длина(строка):
                            raise IndexError("Количество элементов в строках не совпадает")
                    конкретная_матрица.матрица = данные[0]
                else:
                    конкретная_матрица.матрица = [данные[0]]
            elif класс_является_подклассом(данные[0][0], Матрица):
                конкретная_матрица.матрица = данные[0][0].матрица
            else:
                raise TypeError("Неизвестный тип данных, используйте список, или целое_число, или целое_число, целое_число")
        elif длина(данные) == 2:
            if класс_является_подклассом(данные[0], целое_число) and класс_является_подклассом(данные[1], целое_число):
                конкретная_матрица.матрица = [[0 for j in диапазон(данные[1])] for i in диапазон(данные[0])]
        else:
            raise ValueError("Слишком много аргументов")

    def __getitem__(конкретная_матрица, элемент):
        return конкретная_матрица.матрица[элемент]

    def __setitem__(конкретная_матрица, ключ, значение):
        if длина(значение) != конкретная_матрица.количество_столбцов:
            raise IndexError("Ширина новой строки не совпадает с шириной матрицы")
        конкретная_матрица.матрица[ключ] = значение

    def __str__(конкретная_матрица):
        выход = f'Матрица {конкретная_матрица.размер}\n'
        for строка in конкретная_матрица.матрица:
            выход += строка(строка) + '\n'
        return выход

    def __add__(конкретная_матрица, другая_величина):
        if класс_является_подклассом(другая_величина, (дробное_число, целое_число)):
            матрица = конкретная_матрица.копия()
            for номер_строки, номер_столбца in конкретная_матрица:
                матрица[номер_строки][номер_столбца] += другая_величина
            return матрица
        elif класс_является_подклассом(другая_величина, Матрица):
            if конкретная_матрица.размер != другая_величина.размер:
                raise ArithmeticError("Нельзя сложить матрицы разного размера")
            матрица = конкретная_матрица.копия()
            for номер_строки, номер_столбца in конкретная_матрица:
                матрица[номер_строки][номер_столбца] += другая_величина[номер_строки][номер_столбца]
            return матрица

    def __mul__(конкретная_матрица, другая_величина):
        if класс_является_подклассом(другая_величина, Матрица):
            if конкретная_матрица.количество_столбцов != другая_величина.количество_строк:
                if not конкретная_матрица.вектор_ли and not другая_величина.вектор_ли:
                    raise IndexError("Количество столбцов первой матрицы не совпадает с количеством строк второй")
                else:
                    try:
                        return конкретная_матрица * другая_величина.транспонированная
                    except IndexError:
                        return конкретная_матрица.транспонированная * другая_величина
            матрица = Матрица(конкретная_матрица.количество_строк, другая_величина.количество_столбцов)
            for номер_строки_первой in конкретная_матрица.диапазон_строк:
                for номер_столбца_второй in другая_величина.диапазон_столбцов:
                    for номер_столбца_первой in конкретная_матрица.диапазон_столбцов:
                        if конкретная_матрица.количество_строк > 1:
                            матрица[номер_строки_первой][номер_столбца_второй] += конкретная_матрица[номер_строки_первой][номер_столбца_первой] * другая_величина[номер_столбца_первой][номер_столбца_второй]
                        else:
                            матрица[номер_строки_первой][номер_столбца_второй] += конкретная_матрица[номер_столбца_первой] * другая_величина[номер_столбца_первой][номер_столбца_второй]
            return матрица
        else:
            матрица = конкретная_матрица.копия()
            for номер_строки, номер_столбца in конкретная_матрица:
                матрица[номер_строки][номер_столбца] *= другая_величина
            return матрица

    def __neg__(конкретная_матрица):
        return конкретная_матрица * -1

    def __sub__(конкретная_матрица, другая_величина):
        return конкретная_матрица + (-другая_величина)

    def __truediv__(конкретная_матрица, другая_величина):
        if класс_является_подклассом(другая_величина, Матрица):
            return конкретная_матрица * ~другая_величина
        else:
            return конкретная_матрица * (1 / другая_величина)

    def __invert__(конкретная_матрица):
        """Обратная матрица"""
        if определитель(конкретная_матрица) == 0:
            raise ArithmeticError("Невозможно найти обратную матрицу так как определитель равен нулю")
        else:
            return конкретная_матрица.алгебраические_дополнения.транспонированная / определитель(конкретная_матрица)

    def __eq__(конкретная_матрица, другая_величина):
        if класс_является_подклассом(другая_величина, Матрица):
            return конкретная_матрица.матрица == другая_величина.матрица
        else:
            return False

    def __hash__(конкретная_матрица):
        return hash(строка(конкретная_матрица.матрица))

    def __len__(конкретная_матрица):
        return конкретная_матрица.количество_столбцов * конкретная_матрица.количество_строк

    def __iter__(конкретная_матрица):
        def iterator():
            for номер_строки in конкретная_матрица.диапазон_строк:
                for номер_столбца in конкретная_матрица.диапазон_столбцов:
                    yield номер_строки, номер_столбца
        return iterator()

    def применить_ко_всем(конкретная_матрица, func: callable, *args, **kwargs):
        """
        Применяет указанную функцию ко всем элементам матрицы с указанными далее агрументами

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.применить_ко_всем(модуль)

        Args:
            func (callable): Функция, которая будет применена к каждому элементу матрицы
            *args (): Аргументы, с которыми будет применена функция
            **kwargs (): Ключевые аргументы, с которыми будет применена функция

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        for номер_строки, номер_столбца in матрица:
            матрица[номер_строки][номер_столбца] = func(матрица[номер_строки][номер_столбца], *args, **kwargs)
        return матрица

    def показать_в_консоли(конкретная_матрица) -> None:
        """
        Красиво печатет матрицу в консоль
        """
        напечатать_в_консоль(f'Матрица {конкретная_матрица.размер}'.center(конкретная_матрица.количество_столбцов * (конкретная_матрица.максимальная_длина_числа + 3) - 1))
        напечатать_в_консоль(конкретная_матрица.получить_красивую_таблицу())

    def заполнить_случайными(конкретная_матрица, начало: (целое_число, дробное_число) = -10, конец: (целое_число, дробное_число) = 10) -> None:
        """
        Заполняет матрицу случайными числами, принадлежащими указанному отрезку. Меняет исходную матрицу.
        Если указанные края отрезка - целые числа, матрица будет заполнена целыми числами,
        иначе - числами с плавающей точкой

        Args:
            начало (целое_число, дробное_число): левый край отрезка (по умолчанию -10)
            конец (целое_число, дробное_число): правый край отрезка (по умолчанию 10)

        Returns:
            None

        Raises:
              IndexError: если длина выбранного отрезка равна нулю

        """
        начало, конец = минимальное_значение(начало, конец), максимальное_значение(начало, конец)
        if конец - начало == 0:
            raise IndexError("Выбран пустой диапазон")
        if класс_является_подклассом(начало, дробное_число) or класс_является_подклассом(конец, дробное_число):
            конкретная_матрица.матрица = [[rnd.uniform(начало, конец) for номер_столбца in конкретная_матрица.диапазон_столбцов] for номер_строки in конкретная_матрица.диапазон_строк]
        else:
            конкретная_матрица.матрица = [[rnd.randint(начало, конец) for номер_столбца in конкретная_матрица.диапазон_столбцов] for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_значением(конкретная_матрица, значение=1) -> None:
        """
        Заполняет матрицу указанным значением. Меняет исходную матрицу.

        Args:
            значение (Any): значение-наполнитель (по умолчанию 1)

        Returns:
            None
        """
        конкретная_матрица.матрица = [[значение for номер_столбца in конкретная_матрица.диапазон_столбцов] for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_до_единичной(конкретная_матрица) -> None:
        """
        Превращает матрицу в единичную. Меняет исходную матрицу.

        Returns:
            None

        Raises:
              TypeError: если матрица не является квадратной

        """
        if not конкретная_матрица.квадратная_ли:
            raise TypeError("Невозможно составить единичную матрицу из не квадратной матрицы")
        конкретная_матрица.матрица = [[1 if номер_строки == номер_столбца else 0 for номер_столбца in конкретная_матрица.диапазон_столбцов] for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_последовательностью(конкретная_матрица, начало: целое_число = 1) -> None:
        """
        Заполняет матрицу последовательно увеличивающимися числами. Меняет исходную матрицу.
        Например: 1 2 3
                  4 5 6
                  7 8 9
        Args:
            начало (целое_число): начальное значение (по умолчанию 1)

        Returns:
            None
        """
        конкретная_матрица.матрица = [[начало + номер_столбца + номер_строки * конкретная_матрица.количество_столбцов for номер_столбца in конкретная_матрица.диапазон_столбцов] for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_Н_сеткой(конкретная_матрица, значение_наполнитель_1=0, значение_наполнитель_2=1, шаг: целое_число = 1) -> None:
        """
        Заполняет матрицу сеткой значений. Меняет исходную матрицу.
        Например: 1 0 1 0 1
                  1 1 1 1 1
                  1 0 1 0 1
                  1 1 1 1 1
        Args:
            значение_наполнитель_1 (Any): первое значение-наполнитель (по умолчанию 0)
            значение_наполнитель_2 (Any): второе значение-наполнитель (по умолчанию 1)
            шаг (целое_число): шаг сетки (по умолчанию 1)

        Returns:
            None
        """
        конкретная_матрица.матрица = [[значение_наполнитель_1 if логический(номер_строки % (шаг + 1)) or логический(номер_столбца % (шаг + 1)) else значение_наполнитель_2
                                       for номер_столбца in конкретная_матрица.диапазон_столбцов]
                        for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_Х_сеткой(конкретная_матрица, значение_наполнитель_1=0, значение_наполнитель_2=1, шаг: целое_число = 1) -> None:
        """
        Заполняет матрицу сеткой значений. Меняет исходную матрицу.
        Например: 1 0 1 0 1
                  0 1 0 1 0
                  1 0 1 0 1
                  0 1 0 1 0
                  1 0 1 0 1
        Args:
            значение_наполнитель_1 (Any): первое значение-наполнитель (по умолчанию 0)
            значение_наполнитель_2 (Any): второе значение-наполнитель (по умолчанию 1)
            шаг (целое_число): шаг сетки (по умолчанию 1)

        Returns:
            None
        """
        конкретная_матрица.матрица = [[значение_наполнитель_1 if номер_строки % (шаг + 1) == номер_столбца % (шаг + 1) else значение_наполнитель_2
                                       for номер_столбца in конкретная_матрица.диапазон_столбцов]
                        for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_до_доминантной(конкретная_матрица, начало: (целое_число, дробное_число) = -10, конец: (целое_число, дробное_число) = 10) -> None:
        """
        Заполняет матрицу случайными числами с преобладающей диагональю. Значения на главной диагонали могут выходить
        за пределы указанного отрезка. Меняет исходную матрицу.
        Если указанные края отрезка - целые числа, матрица будет заполнена целыми числами,
        иначе - числами с плавающей точкой

        Args:
            начало (целое_число, дробное_число): левый край отрезка (по умолчанию -10)
            конец (целое_число, дробное_число): правый край отрезка (по умолчанию 10)

        Returns:
            None

        Raises:
              TypeError: если матрица не является квадратной

        """
        if not конкретная_матрица.квадратная_ли:
            raise TypeError("Доминантной можно сделать только квадратную матрицу")
        новая_матрица = Матрица(конкретная_матрица.размер[0], конкретная_матрица.размер[1])
        новая_матрица.заполнить_случайными(начало, конец)
        if класс_является_подклассом(начало, дробное_число) or класс_является_подклассом(конец, дробное_число):
            random = rnd.uniform
        else:
            random = rnd.randint
        for номер_строки, номер_столбца in новая_матрица:
            if номер_строки == номер_столбца:
                контейнер = 0
                for номер_столбца_inner in новая_матрица.диапазон_столбцов:
                    if номер_столбца_inner != номер_столбца:
                        контейнер += модуль(новая_матрица[номер_строки][номер_столбца_inner])
                # Гарантия доминации диагонали
                новая_матрица[номер_строки][номер_столбца] = контейнер + модуль(random(начало, конец))
                # Добавление отрицательных значений
                новая_матрица[номер_строки][номер_столбца] *= 1 if rnd.random() < 1 / конкретная_матрица.количество_строк else -1
        конкретная_матрица.матрица = новая_матрица.копия().матрица

    def заполнить_до_трехдиагональной(конкретная_матрица, начало: (целое_число, дробное_число) = -10, конец: (целое_число, дробное_число) = 10) -> None:
        """
        Заполняет три диагонали матрицы случайными числами из указанного отрезка. Меняет исходную матрицу.
        Если указанные края отрезка - целые числа, матрица будет заполнена целыми числами,
        иначе - числами с плавающей точкой

        Args:
            начало (целое_число, дробное_число): левый край отрезка (по умолчанию -10)
            конец (целое_число, дробное_число): правый край отрезка (по умолчанию 10)

        Returns:
            None

        Raises:
              IndexError: если длина выбранного отрезка равна нулю
              TypeError: если матрица не является квадратной

        """
        if not конкретная_матрица.квадратная_ли:
            raise TypeError("рехдиагональной можно сделать только квадратную матрицу")
        начало, конец = минимальное_значение(начало, конец), максимальное_значение(начало, конец)
        if конец - начало == 0:
            raise IndexError("Выбран пустой диапазон")
        if класс_является_подклассом(начало, дробное_число) or класс_является_подклассом(конец, дробное_число):
            random = rnd.uniform
        else:
            random = rnd.randint
        конкретная_матрица.матрица = [[random(начало, конец) if номер_столбца == номер_строки or номер_столбца - 1 == номер_строки or номер_столбца == номер_строки - 1 else 0
                         for номер_столбца in конкретная_матрица.диапазон_столбцов]
                        for номер_строки in конкретная_матрица.диапазон_строк]

    def заполнить_переменными(конкретная_матрица, имя_переменной_элемента: строка = 'a',
                              префикс: строка = '',
                              постфикс: строка = '',
                              начало_нумерации_строк: целое_число = 0,
                              начало_нумерации_столбцов: целое_число = 0) -> None:
        """
        Заполняет матрицу символами Sympy. Меняет исходную матрицу.

        Args:
            имя_переменной_элемента (строка): буква, обозначающая значение элемента матрицы (по умолчанию 'a')
            префикс (строка): префикс (по умолчанию '')
            постфикс (строка): постфикс (по умолчанию '')
            начало_нумерации_строк (целое_число): начало нумерации строк (по умолчанию 0)
            начало_нумерации_столбцов (целое_число): начало нумерации столбцов. (по умолчанию 0)

        Returns:
            None
        """

        def getchar(номер_строки, номер_столбца):
            return f'{префикс}{имя_переменной_элемента}{номер_строки + начало_нумерации_строк}{номер_столбца + начало_нумерации_столбцов}{постфикс}'

        конкретная_матрица.матрица = [[Symbol(getchar(номер_строки, номер_столбца)) for номер_столбца in конкретная_матрица.диапазон_столбцов] for номер_строки in конкретная_матрица.диапазон_строк]

    def удалить_строку_столбец(конкретная_матрица, строка: целое_число, столбец: целое_число):
        """
        Удаляет из матрицы указанную строку и столбец

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.удалить_строку_столбец(1, 1) # вернет матрицу без первой строки и столбца

        Args:
            строка (целое_число): номер строки
            столбец (целое_число): номер столбца

        Returns:
            Матрица: новая матрица
        """
        матрица = конкретная_матрица.копия()
        матрица.удалить_строку(строка)
        матрица.удалить_столбец(столбец)
        return матрица

    def прибавить_к_столбцу(конкретная_матрица, номер_столбца: целое_число, n: (целое_число, дробное_число)):
        """
        Сложение указанного столбца с указанным числом

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.прибавить_к_столбцу(1, .5) # прибавит к каждому элементу столбца 0.5

        Args:
            номер_столбца (целое_число): номер столбца
            n (целое_число, дробное_число): число

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        for номер_строки in конкретная_матрица.диапазон_строк:
            матрица.матрица[номер_строки][номер_столбца] += n
        return матрица

    def прибавить_к_строке(конкретная_матрица, номер_строки: целое_число, n: (целое_число, дробное_число)):
        """
        Сложение указанной строки с указанным числом

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.прибавить_к_строке(1, .7) # прибавит к каждому элементу первой строки 0.7

        Args:
            номер_строки (целое_число): номер строки
            n (целое_число, дробное_число): число

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        матрица.матрица[номер_строки] = [elem + n for elem in матрица.матрица[номер_строки]]
        return матрица

    def умножить_столбец(конкретная_матрица, номер_столбца: целое_число, n: (целое_число, дробное_число)):
        """
        Умножение указанного столбца на указанное число

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.умножить_столбец(2, 0) # умножит второй столбец на 0

        Args:
            номер_столбца (целое_число): номер столбца
            n (целое_число, дробное_число): число

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        for номер_строки in конкретная_матрица.диапазон_строк:
            матрица.матрица[номер_строки][номер_столбца] *= n
        return матрица

    def умножить_строку(конкретная_матрица, номер_строки: целое_число, n: (целое_число, дробное_число)):
        """
        Умножение указанной строки на указанное число

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.умножить_строку(0, 0) # Умножит нулевую строку на 0

        Args:
            номер_строки (целое_число): номер строки
            n (целое_число, дробное_число): число

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        матрица.матрица[номер_строки] = [elem * n for elem in матрица.матрица[номер_строки]]
        return матрица

    def возвести_строку_в_степень(конкретная_матрица, номер_строки: целое_число, n: (целое_число, дробное_число)):
        """
        Возведение указанной строки в указанную степень

        Examples:
            >>>матрица = Матрица(3)
            >>>матрица.возвести_строку_в_степень(1, 2) # возведет в квадрат каждый элемент первой строки

        Args:
            номер_строки (целое_число): номер строки
            n (целое_число, дробное_число): степень

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        матрица.матрица[номер_строки] = [elem ** n for elem in матрица.матрица[номер_строки]]
        return матрица

    def возвести_столбец_в_степень(конкретная_матрица, номер_столбца: целое_число, n: (целое_число, дробное_число)):
        """
        Возведение указанного столбца в указанную степень

        Args:
            номер_столбца (целое_число): номер столбца
            n (целое_число, дробное_число): степень

        Returns:
            Матрица: новая матрица

        """
        новая_матрица = конкретная_матрица.копия()
        for номер_строки in новая_матрица.диапазон_строк:
            новая_матрица[номер_строки][номер_столбца] **= n
        return новая_матрица

    def применить_маску(конкретная_матрица, другая_величина):
        """
        Применяет маску (перемножает соответствующие элементы двух матриц)

        Args:
            другая_величина (Матрица): матрица-маска

        Returns:
            Матрица: новая матрица

        Raises:
            TypeError: если маска не является матрицей
            ArithmeticError: если маска не соответствеует размеру матрицы

        """
        if not класс_является_подклассом(другая_величина, Матрица):
            raise TypeError("Маска тоже должна быть матрицей")
        if конкретная_матрица.размер != другая_величина.размер:
            raise IndexError("Маска должна быть соответствующего размера")
        матрица = конкретная_матрица.копия()
        for номер_строки, номер_столбца in конкретная_матрица:
            матрица.матрица[номер_строки][номер_столбца] *= другая_величина.матрица[номер_строки][номер_столбца]
        return матрица

    def поменять_строки_местами(конкретная_матрица, строка_1: целое_число, строка_2: целое_число):
        """
        Меняет две строки местами

        Args:
            строка_1 (целое_число): номер первой строки
            строка_2 (целое_число): номер второй строки

        Returns:
            Матрица: новая матрица

        """
        новая_матрица = конкретная_матрица.копия()
        новая_матрица[строка_1], новая_матрица[строка_2] = новая_матрица[строка_2], новая_матрица[строка_1]
        return новая_матрица

    def поменять_стобцы_местами(конкретная_матрица, столбец_1: целое_число, столбец_2: целое_число):
        """
        Меняет два столбца местами

        Args:
            столбец_1 (целое_число): номер первого столбца
            столбец_2 (целое_число): номер второго столбика

        Returns:
            Матрица: новая матрица

        """
        матрица = конкретная_матрица.копия()
        for номер_строки in диапазон(конкретная_матрица.количество_строк):
            матрица[номер_строки][столбец_1], матрица[номер_строки][столбец_2] = матрица[номер_строки][столбец_2], матрица[номер_строки][столбец_1]
        return матрица

    def найти_максимальное_количество_вхождений(конкретная_матрица, num=0) -> целое_число:
        """
        Устарел
        Ищет строку с наибольшим количеством указаной величины (по умолчанию 0), если такой нет - вернет 0

        Args:
            num (Any): число, количество вхождений которого нужно определить

        Returns:
            целое_число: номер строки с наибольшим количеством вхождений указаной величины, если такой нет - вернет 0

        """
        counter = конкретная_матрица.матрица.count(num)
        максимальное_значение_nums_номер_строки = 0
        for номер_строки in конкретная_матрица.диапазон_строк:
            if конкретная_матрица[номер_строки].count(num) > counter:
                counter = конкретная_матрица[номер_строки].count(num)
                максимальное_значение_nums_номер_строки = номер_строки
        return максимальное_значение_nums_номер_строки

    def посчитать_в_строке(конкретная_матрица, номер_строки: целое_число, значение, invert: логический = False) -> целое_число:
        """
        Считает сколько содержится в указанной строке указанных элементов

        Args:
            номер_строки (целое_число): номер строки
            значение (Any): значение, количество вхождений которонго нужно определить
            invert (логический): флаг, если True, то ищет сколько элементов в строке не соответствует значение

        Returns:
            целое_число: количество вхождений элемента в строке

        """
        if not invert:
            return конкретная_матрица.матрица[номер_строки].count(значение)
        else:
            return конкретная_матрица.количество_столбцов - конкретная_матрица.посчитать_в_строке(номер_строки, значение)

    def посчитать_в_столбце(конкретная_матрица, номер_столбца: целое_число, значение, invert: логический = False) -> целое_число:
        """
        Считает сколько содержится в указанном столбце указанных элементов

        Args:
            номер_столбца (целое_число): номер столбца
            значение (Any): значение, количество вхождений которонго нужно определить
            invert (логический): флаг, если True, то ищет сколько элементов в строке не соответствует значение

        Returns:
            целое_число: количество вхождений элемента в строке

        """
        if not invert:
            return конкретная_матрица.транспонированная.матрица[номер_столбца].count(значение)
        else:
            return конкретная_матрица.транспонированная.количество_столбцов - конкретная_матрица.посчитать_в_столбце(номер_столбца, значение)

    def добавить_строку(конкретная_матрица, новая_строка: список) -> None:
        """
        Добавляет новую строку в матрицу. Меняет исходную матрицу
        Args:
            новая_строка (список): новая строка

        Returns:
            None

        Raises:
            IndexError: если длина новой строки не равна количеству столбцов матрицы

        """
        if длина(новая_строка) == конкретная_матрица.количество_столбцов:
            конкретная_матрица.матрица.append(новая_строка)
        else:
            raise IndexError("Ширина новой строки не равна ширине матрицы")

    def добавить_столбец(конкретная_матрица, new_column: список) -> None:
        """
        Добавляет новый столбец в матрицу. Меняет исходную матрицу

        Args:
            new_column (список): новый столбец

        Returns:
            None

        Raises:
            IndexError: если количество элементов нового столбца не равна количеству строк матрицы

        """
        if длина(new_column) != конкретная_матрица.количество_строк:
            raise IndexError("Высота нового столбца не равна высоте матрицы")
        else:
            for строка, new_val in zip(конкретная_матрица.матрица, new_column):
                строка.append(new_val)

    def удалить_столбец(конкретная_матрица, номер_столбца: целое_число) -> список:
        """
        Удаляет столбец из матрицы. Меняет исходную матрицу

        Args:
            номер_столбца (целое_число): номер столбца

        Returns:
            список: удаленный столбец

        """
        выход_col = []
        for номер_строки in конкретная_матрица.диапазон_строк:
            выход_col.append(конкретная_матрица.матрица[номер_строки].pop(номер_столбца))
        return выход_col

    def удалить_строку(конкретная_матрица, номер_строки: целое_число) -> список:
        """
        Удаляет строку из матрицы. Меняет исходную матрицу

        Args:
            номер_строки (целое_число): номер строки

        Returns:
            список: удаленная строка
        """
        return конкретная_матрица.матрица.pop(номер_строки)

    def вставить_строку(конкретная_матрица, номер_строки: целое_число, строка: список) -> None:
        """
        Вставляет строку в указанное место в исходную матрицу. Меняет исходную матрицу

        Args:
            номер_строки (целое_число): номер позиции
            строка (список): новая строка

        Returns:
            None

        Raises:
            IndexError: если длина новой строки не равна количеству столбцов матрицы

        """
        if длина(строка) != конкретная_матрица.количество_столбцов:
            raise IndexError("Ширина новой строки не равна ширине матрицы")
        конкретная_матрица.матрица.insert(номер_строки, строка)

    def вставить_столбец(конкретная_матрица, номер_столбца: целое_число, новый_столбец: список) -> None:
        """
        Вставляет столбец в указанное место в исходную матрицу. Меняет исходную матрицу

        Args:
            номер_столбца (целое_число): номер столбца
            новый_столбец (список): новый столбец

        Returns:
            None

        Raises:
            IndexError: если количество элементов нового столбца не равна количеству строк матрицы

        """
        if длина(новый_столбец) != конкретная_матрица.количество_строк:
            raise IndexError("Высота нового столбца не равна высоте матрицы")
        for номер_строки in конкретная_матрица.диапазон_строк:
            конкретная_матрица.матрица[номер_строки].insert(номер_столбца, новый_столбец[номер_строки])

    def сохранить_в_файл(конкретная_матрица, имя_файла: строка) -> None:
        """
        Записывает матрицу в файл

        Args:
            имя_файла (строка): имя файла

        Returns:
            None

        """
        with open(имя_файла + '.матрица', 'wb') as file:
            pickle.dump(конкретная_матрица.матрица, file)

    def получить_красивую_таблицу(конкретная_матрица, round_to: целое_число = 8) -> строка:
        """
        Возвращает строку, содержащую матрицу сформированную таблицей

        Args:
            round_to (целое_число): количество знаков после точки

        Returns:
            строка: строковое представление таблицы

        """
        максимальное_значение_длины_элемента = конкретная_матрица.максимальная_длина_числа
        pretty_строкаing = ' ' + '_' * (конкретная_матрица.количество_столбцов * (максимальное_значение_длины_элемента + 3) - 1) + ' \n'
        for номер_строки in конкретная_матрица.диапазон_строк:
            for номер_столбца in конкретная_матрица.диапазон_столбцов:
                if класс_является_подклассом(конкретная_матрица[номер_строки][номер_столбца], (целое_число, дробное_число)):
                    pretty_строкаing += f'|' \
                                     f'{строка(round(конкретная_матрица[номер_строки][номер_столбца], round_to)).center(максимальное_значение_длины_элемента + 2)}'
                else:
                    pretty_строкаing += f'|{строка(конкретная_матрица[номер_строки][номер_столбца]).center(максимальное_значение_длины_элемента + 2)}'
            pretty_строкаing += "|\n" + ("|" + "_" * (максимальное_значение_длины_элемента + 2)) * конкретная_матрица.количество_столбцов + "|\n"
        return pretty_строкаing

    def копия(конкретная_матрица):
        """
        Глубокая копия матрицы

        Returns:
            Матрица: новая матрица

        """
        новая_матрица = Матрица(список(copy.deepcopy(конкретная_матрица.матрица)))
        return новая_матрица

    def триангулировать(конкретная_матрица):
        """
        Триангулирует матрицу

        Returns:
            Матрица: новая матрица

        """

        def умножить_строку(строка, n):
            return [val * n for val in строка]

        def сложить_строки(строка1, строка2):
            return [val1 - val2 for val1, val2 in zip(строка1, строка2)]

        триангулировання_матрица = конкретная_матрица.копия()
        for номер_столбца in диапазон(минимальное_значение(триангулировання_матрица.количество_столбцов, триангулировання_матрица.количество_строк)):
            for номер_строки in диапазон(триангулировання_матрица.количество_строк - 1, 0, -1):
                if номер_столбца == номер_строки:
                    break
                try:
                    умноженная_строка = умножить_строку(триангулировання_матрица[номер_строки - 1],
                                              триангулировання_матрица[номер_строки][номер_столбца] /
                                              триангулировання_матрица[номер_строки - 1][номер_столбца])
                    триангулировання_матрица[номер_строки] = сложить_строки(триангулировання_матрица[номер_строки], умноженная_строка)
                except ZeroDivisionError:
                    continue
        return триангулировання_матрица

    def триангулировать_до_единиц_в_диагонали(конкретная_матрица):
        """
        Возвращает триангулированную матрицу с единицами в главной диагонали (возможно и нулями)

        Returns:
            Матрица: новая матрица

        """

        def умножить_строку(строка, n):
            return [val * n for val in строка]

        матрица = конкретная_матрица.копия()
        матрица = матрица.триангулировать()
        for номер_строки, номер_столбца in матрица:
            if номер_строки == номер_столбца:
                try:
                    матрица.матрица[номер_строки] = умножить_строку(матрица[номер_строки], 1 / матрица[номер_строки][номер_столбца])
                except ZeroDivisionError:
                    continue
        return матрица

    def скалярное_произведение_векторов(конкретная_матрица, другая_величина) -> (целое_число, дробное_число):
        """
        Скалярное произведение векторов

        Args:
            другая_величина (Матрица): второй вектор (матрица с 1 столбцом или 1 строкой)

        Returns:
            целое_число, дробное_число: результат скалярного произведения

        Raises:
            TypeError: если конкретная_матрица или другая_величина не являются вектором (матрицей с 1 столбцом или 1 строкой)
            IndexError: если размерности векторов не равны

        """
        if not конкретная_матрица.вектор_ли:
            TypeError("Скалярное произведение только для векторов (матриц с 1 столбцом или 1 строкой)")
        if класс_является_подклассом(другая_величина, Матрица):
            if not другая_величина.вектор_ли:
                TypeError("Скалярное произведение только для векторов (матриц с 1 столбцом или 1 строкой)")
        else:
            return конкретная_матрица.скалярное_произведение_векторов(Матрица(другая_величина))
        if конкретная_матрица.количество_строк != другая_величина.количество_строк and конкретная_матрица.количество_строк != другая_величина.транспонированная.количество_строк:
            raise IndexError("Скалярное произведение можно найти только у векторов равной размерности")
        return сумма_всех((elem_1 * elem_2 for elem_1, elem_2 in zip(конкретная_матрица.вектор_в_список, другая_величина.вектор_в_список)))

    @свойство
    def матрица(конкретная_матрица):
        return конкретная_матрица.контейнер_для_матрицы

    @матрица.setter
    def матрица(конкретная_матрица, новое_значение):
        if not класс_является_подклассом(новое_значение, список):
            новое_значение = список(новое_значение)
        if длина(новое_значение) == 0:
            новое_значение.append([])
        for номер_строки in диапазон(длина(новое_значение)):
            if длина(новое_значение[0]) != длина(новое_значение[номер_строки]):
                raise IndexError("Длины строк матрицы не равны")
        конкретная_матрица.контейнер_для_матрицы = новое_значение

    @свойство
    def вектор_в_список(конкретная_матрица):
        """
        Преобразование вектора в список (только для матриц с одним столбцом или строкой)
        """
        if конкретная_матрица.количество_строк > 1:
            временная_переменная = конкретная_матрица.транспонированная
            if временная_переменная.количество_строк != 1:
                raise ArithmeticError("В список можно превратить только вектор")
            return временная_переменная.матрица[0]
        else:
            if конкретная_матрица.количество_строк != 1:
                raise ArithmeticError("В список можно превратить только вектор")
            return конкретная_матрица.матрица[0]

    @свойство
    def векторная_норма_1(конкретная_матрица) -> (дробное_число, целое_число):
        """
        Первая норма вектора (только для матриц с одним столбцом или строкой)
        """
        return максимальное_значение(применить_ко_всем(модуль, конкретная_матрица.вектор_в_список))

    @свойство
    def векторная_норма_2(конкретная_матрица) -> (целое_число, дробное_число):
        """
        Вторая норма вектора (только для матриц с одним столбцом или строкой)
        """
        return сумма_всех(применить_ко_всем(модуль, конкретная_матрица.вектор_в_список))

    @свойство
    def векторная_норма_3(конкретная_матрица) -> дробное_число:
        """
        Третья норма вектора (только для матриц с одним столбцом или строкой)
        """
        return сумма_всех((элемент ** 2 for элемент in конкретная_матрица.вектор_в_список)) ** .5

    @свойство
    def матричная_норма_1(конкретная_матрица) -> дробное_число:
        """
        Первая норма матрицы (по строкам)
        """
        return максимальное_значение((сумма_всех(применить_ко_всем(lambda x: модуль(x), строка)) for строка in конкретная_матрица.матрица))

    @свойство
    def матричная_норма_2(конкретная_матрица) -> дробное_число:
        """
        Вторая норма матрицы (по столбцам)
        """
        норма = []
        for номер_столбца in конкретная_матрица.диапазон_столбцов:
            сумма_столбца = 0
            for номер_строки in конкретная_матрица.диапазон_строк:
                сумма_столбца += модуль(конкретная_матрица[номер_строки][номер_столбца])
            норма.append(сумма_столбца)
        норма = максимальное_значение(норма)
        return норма

    @свойство
    def матричная_норма_3(конкретная_матрица) -> дробное_число:
        """
        Третья норма матрицы
        """
        return сумма_всех((конкретная_матрица[номер_строки][номер_столбца] ** 2 for номер_строки, номер_столбца in конкретная_матрица)) ** .5

    @свойство
    def преобладающая_ли_диагональ(конкретная_матрица) -> логический:
        """
        Определяет является ли диагональ матрицы доминантной
        """
        if not конкретная_матрица.квадратная_ли:
            return False
        for номер_строки in конкретная_матрица.диапазон_строк:
            контейнер = 0
            for номер_столбца in конкретная_матрица.диапазон_столбцов:
                if номер_строки == номер_столбца:
                    continue
                контейнер += модуль(конкретная_матрица[номер_строки][номер_столбца])
            if контейнер > модуль(конкретная_матрица[номер_строки][номер_строки]):
                return False
        else:
            return True

    @свойство
    def максимальная_длина_числа(конкретная_матрица, round_to: целое_число = 8):
        """
        Длина максимального строкового представления чисел. Для получить_красивую_таблицу
        """
        контейнер = 0
        for строка_ in конкретная_матрица.матрица:
            for element in строка_:
                if класс_является_подклассом(element, (целое_число, дробное_число)):
                    контейнер = максимальное_значение(длина(строка(round(element, round_to))), контейнер)
                else:
                    контейнер = максимальное_значение(длина(строка(element)), контейнер)
        return контейнер

    @свойство
    def алгебраические_дополнения(конкретная_матрица):
        """
        Матрица алгебраических дополнений
        """
        матрица = конкретная_матрица.копия()
        for номер_строки, номер_столбца in конкретная_матрица:
            матрица[номер_строки][номер_столбца] = определитель(конкретная_матрица.удалить_строку_столбец(номер_строки, номер_столбца))
        for номер_строки, номер_столбца in конкретная_матрица:
            if логический((номер_строки + номер_столбца) % 2):
                матрица[номер_строки][номер_столбца] = -матрица[номер_строки][номер_столбца]
        return матрица

    @свойство
    def транспонированная(конкретная_матрица):
        """
        Транспонированная матрица
        """
        выход = []
        for номер_столбца in конкретная_матрица.диапазон_столбцов:
            новый_столбец = []
            for номер_строки in конкретная_матрица.диапазон_строк:
                новый_столбец.append(конкретная_матрица.матрица[номер_строки][номер_столбца])
            выход.append(новый_столбец)
        return Матрица(выход)

    @свойство
    def размер(конкретная_матрица) -> кортеж:
        """
        Размер матрицы (строки, столбцы)
        """
        return конкретная_матрица.количество_строк, конкретная_матрица.количество_столбцов

    @свойство
    def количество_строк(конкретная_матрица) -> целое_число:
        """
        Количество строк в матрице
        """
        return длина(конкретная_матрица.матрица)

    @свойство
    def количество_столбцов(конкретная_матрица) -> целое_число:
        """
        Количество столбцов в матрице
        """
        try:
            return длина(конкретная_матрица.матрица[0])
        except IndexError:
            return 0

    @свойство
    def квадратная_ли(конкретная_матрица) -> логический:
        """
        Проверяет, является ли матрица квадратной
        """
        return конкретная_матрица.количество_столбцов == конкретная_матрица.количество_строк

    @свойство
    def трехдиагональная_ли(конкретная_матрица) -> логический:
        """
        Является ли матрица трехдиагональной
        """
        if not конкретная_матрица.квадратная_ли:
            return False
        for номер_строки, номер_столбца in конкретная_матрица:
            if not (номер_строки == номер_столбца or номер_строки - 1 == номер_столбца or номер_строки == номер_столбца - 1):
                if конкретная_матрица[номер_строки][номер_столбца] != 0:
                    return False
        else:
            return True

    @свойство
    def симметричная_ли(конкретная_матрица) -> логический:
        """
        Проверка на симметриюотносительно главной диагонали
        """
        if not конкретная_матрица.квадратная_ли:
            raise IndexError("Симметричной можетбыть только квадратная матрица")
        for номер_строки, номер_столбца in конкретная_матрица:
            if конкретная_матрица[номер_строки][номер_столбца] != конкретная_матрица[номер_столбца][номер_строки]:
                return False
        else:
            return True

    @свойство
    def вектор_ли(конкретная_матрица):
        """
        Проверяет является ли объект вектором
        """
        return 1 in конкретная_матрица.размер

    @свойство
    def диапазон_строк(конкретная_матрица):
        """диапазон(конкретная_матрица.количество_строк)"""
        return диапазон(конкретная_матрица.количество_строк)

    @свойство
    def диапазон_столбцов(конкретная_матрица):
        """диапазон(конкретная_матрица.количество_столбцов)"""
        return диапазон(конкретная_матрица.количество_столбцов)

    @свойство
    def к_списку(конкретная_матрица) -> список:
        """
        Returns:
            список: матрица, преобразованная к двумерному списку, вектор к одномерному
        """
        if конкретная_матрица.вектор_ли:
            return конкретная_матрица.вектор_в_список
        else:
            return конкретная_матрица.матрица

    @staticmethod
    def обернуть(*args, **kwargs):
        """
        Возвращает новую матрицу, не меняя исходную
        """
        return Матрица(*args, **kwargs)

    @staticmethod
    def получить_нормированный_по_3_норме_вектор(размерность_вектора):
        """
        Возвращает нормированный вектор нужного размера (по 3 норме)
        """
        return Матрица([[1 / размерность_вектора ** .5 for _ in диапазон(размерность_вектора)]])

    @staticmethod
    def загрузить_из_файла(имя_файла: строка):
        """
        Загружает матрицу из файла

        Args:
            имя_файла (строка): имя файла

        Returns:
            Матрица: новая матрица

        """
        with open(имя_файла + '.матрица', 'rb') as file:
            return Матрица(pickle.load(file))


def решить(матрица: (список, Матрица), столбец_свободных_членов: (список, Матрица)) -> список:
    """Решение СЛАУ оптимальным методом"""
    if класс_является_подклассом(матрица, список):
        матрица = Матрица(матрица)
    if класс_является_подклассом(столбец_свободных_членов, Матрица):
        столбец_свободных_членов = столбец_свободных_членов.вектор_в_список
    solution = None
    if матрица.преобладающая_ли_диагональ or матрица.трехдиагональная_ли:
        decision = iterations.auto_iterate(матрица, столбец_свободных_членов)
    else:
        # TODO: разобраться в причине неработоспособности метода Гаусса
        # decision = gauss.gauss_method(матрица, free_column)
        decision = kramer_method(матрица, столбец_свободных_членов)
    for шаг in decision:
        solution = шаг.get('Решение')
    return solution
